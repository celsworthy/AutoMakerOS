package celtech.roboxbase.configuration.slicer;

import celtech.roboxbase.BaseLookup;
import celtech.roboxbase.configuration.BaseConfiguration;
import celtech.roboxbase.configuration.RoboxProfile;
import celtech.roboxbase.configuration.SlicerType;
import celtech.roboxbase.configuration.datafileaccessors.PrintProfileSettingsContainer;
import celtech.roboxbase.configuration.fileRepresentation.SlicerMappingData;
import celtech.roboxbase.configuration.profilesettings.PrintProfileSetting;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import libertysystems.stenographer.Stenographer;
import libertysystems.stenographer.StenographerFactory;

/**
 *
 * @author Ian and George Salter
 */
public abstract class SlicerConfigWriter {

    private static final Stenographer STENO = StenographerFactory.getStenographer(
        Slic3rConfigWriter.class.getName());
    
    static final PrintProfileSettingsContainer PRINT_PROFILE_SETTINGS_CONTAINER = PrintProfileSettingsContainer.getInstance();

    Map<String, PrintProfileSetting> printProfileSettingsMap = new HashMap<>();
    
    private static final String FLOAT = "float";
    private static final String INT = "int";
    private static final String BOOLEAN = "boolean";
    private static final String OPTION = "option";
    private static final String NOZZLE = "nozzle";
    private static final String EXTRUSION = "extrusion";
    private static final String NUMBER_LIST = "numbers";
    
    SlicerType slicerType = null;
    private SimpleDateFormat dateFormatter = null;
    protected NumberFormat threeDPformatter;

    private float centreX = 0;
    private float centreY = 0;

    private final String parameterDivider = ":";
    private final String queryDivider = "?";
    private final String optionalDivider = "->";
    private final String equivalenceDivider = "=";

    public SlicerConfigWriter() {
        dateFormatter = new SimpleDateFormat("EEE d MMM y HH:mm:ss", Locale.UK);
        threeDPformatter = DecimalFormat.getNumberInstance(Locale.UK);
        threeDPformatter.setMaximumFractionDigits(3);
        threeDPformatter.setGroupingUsed(false);
    }

    public final void generateConfigForSlicer(RoboxProfile profileData, String destinationFile) {
        SlicerMappingData mappingData = BaseLookup.getSlicerMappings().getMappings().get(slicerType);
        profileData = extractNonOverridenSettings(profileData);
        generateConfigForSlicerWithMappings(profileData, destinationFile, mappingData);
    }

    /**
     * Generates a .roboxprofile file which takes into account the user slicer preferences,
     * and the slicermappings.dat file, which will map the options for a particular slicer.
     * 
     * @param profileData the user slicer parameters.
     * @param destinationFile the destination for the .roboxprofile file.
     * @param mappingData The mapping data from the slicermappings.dat file.
     */
    public final void generateConfigForSlicerWithMappings(RoboxProfile profileData,
        String destinationFile, SlicerMappingData mappingData) {

        bringDataInBounds(profileData);

        File outputFile = new File(destinationFile);
        FileWriter writer = null;

        try {
            writer = new FileWriter(outputFile);

            String dateString = dateFormatter.format(new Date());
            writer.write("#Slicer configuration generated by AutoMaker on " + dateString + "\n");
            writer.write(
                "#"
                + BaseConfiguration.getApplicationName()
                + " version "
                + BaseConfiguration.getApplicationVersion()
                + "\n");
            writer.write("#Slicer type " + slicerType.name() + "\n");
            writer.write("#Profile " + profileData.getName()+ "\n");
            writer.write("#\n");

            if(slicerType == SlicerType.Cura4) {
                outputFilamentDiameter(writer, BaseConfiguration.filamentDiameter);
            } else {
                outputFilamentDiameter(writer,
                                   BaseConfiguration.filamentDiameterToYieldVolumetricExtrusion);
            }

            outputPrintCentre(writer, centreX, centreY);

            //Process the defaults
            for (String defaultData : mappingData.getDefaults())
            {
                // This is a default value for the slicer - don't look it up.
                String[] valueElements = defaultData.split(":");
                String variableName = valueElements[0];

                String value = "";
                if (valueElements.length == 2)
                {
                    value = valueElements[1];
                }

                STENO.debug("Writing default " + variableName);
                outputLine(writer, variableName, value);
            }

            for (Map.Entry<String, String> entry : mappingData.getMappingData().entrySet()) {
                String targetVariableName = entry.getKey();
                String settingNameOrValue = extractSettingNameOrValue(entry.getValue());

                try {
                    float value = Float.parseFloat(settingNameOrValue);
                    Optional<Float> calculatedValue = applyValue(profileData, value, entry.getValue());
                    if (calculatedValue.isPresent()) {
                        if(slicerType == SlicerType.Cura4) {
                            outputLine(writer, targetVariableName,
                                   calculatedValue.get());
                        } else {
                            outputLine(writer, targetVariableName,
                                   calculatedValue.get().intValue());
                        }
                    }
                } catch (NumberFormatException nfe) {
                    Optional<String> settingType = getSettingType(settingNameOrValue);
                    
                    if(settingType.isPresent()) {
                        switch (settingType.get()) {
                            case BOOLEAN: {
                                boolean value = profileData.getSpecificBooleanSetting(settingNameOrValue);
                                outputLine(writer, targetVariableName, value);
                                break;
                            }
                            case INT: {
                                if(isSettingPerExtruder(settingNameOrValue)) {
                                    outputLine(writer, targetVariableName, profileData.getSpecificSettingAsString(settingNameOrValue));
                                } else {
                                    int value = profileData.getSpecificIntSetting(settingNameOrValue);
                                    Optional<Float> calculatedValue = applyValue(profileData, value, entry.getValue());
                                    if (calculatedValue.isPresent()) {
                                        outputLine(writer, targetVariableName, calculatedValue.get().intValue());
                                    }
                                }
                                break;
                            }
                            case NOZZLE: {
                                    int value = profileData.getSpecificIntSetting(settingNameOrValue);
                                    // Do not override the nozzle if we have anything other than 0 or 1
                                    value = value > 1 ? -1 : value;
                                    outputLine(writer, targetVariableName, value);
                                break;
                            }
                            case FLOAT:
                            case EXTRUSION: {
                                if(isSettingPerExtruder(settingNameOrValue)) {
                                    outputLine(writer, targetVariableName, profileData.getSpecificSettingAsString(settingNameOrValue));
                                } else {
                                    float value = profileData.getSpecificFloatSetting(settingNameOrValue);
                                    Optional<Float> calculatedValue = applyValue(profileData, value, entry.getValue());
                                    if (calculatedValue.isPresent()) {
                                        outputLine(writer, targetVariableName, calculatedValue.get());
                                    }
                                }
                                break;
                            }
                            case OPTION: {
                                String value = profileData.getSpecificSettingAsString(settingNameOrValue);
                                outputLine(writer, targetVariableName, value);
                                break;
                            }
                            case NUMBER_LIST: {
                                String value = profileData.getSpecificSettingAsString(settingNameOrValue);
                                value = formatStringIntoList(value);
                                outputLine(writer, targetVariableName, value);
                                break;
                            }
                            default:
                                STENO.error("Got unknown return type: " + settingType.get());
                                break;
                        }
                    }
                }
            }
        } catch (FileNotFoundException ex)
        {
            STENO.error("Couldn't open slicer settings file for writing - " + destinationFile
                + " : " + ex.getMessage());
        } catch (IOException ex)
        {
            STENO.error("IO Exception whilst writing slic3r settings - " + destinationFile + " : "
                + ex.getMessage());
        } finally {
            if (writer != null) {
                try {
                    writer.close();
                } catch (IOException ex) {
                    STENO.error("Failed to close configuration file " + outputFile.getName());
                }
            }
        }
    }

    /**
     *
     * @param x
     * @param y
     */
    public void setPrintCentre(float x, float y)
    {
        centreX = x;
        centreY = y;
    }

    /**
     * Evaluates an operation given by a particular mapping and manipulates the 
     * profileData value based on the operation.
     * 
     * @param profileData the user slicer parameters.
     * @param value the value in the parameters file.
     * @param operationString the operation to be applied to the value.
     * @return the new value after an operation has been applied/
     */
    private Optional<Float> applyValue(RoboxProfile profileData, float value,
        String operationString)
    {
        float resultingValue = value;

        if (operationString.contains(parameterDivider))
        {
            String[] valueElements = operationString.split(parameterDivider);

            boolean doneProcessing = false;

            if (valueElements.length > 1)
            {
                for (int elementCounter = 1; elementCounter < valueElements.length; elementCounter++)
                {
                    boolean optionalOperatorDetected = false;

                    String operation = valueElements[elementCounter];
                    String operator = operation.substring(0, 1);
                    String variable = operation.substring(1);

                    if (operation.contains(queryDivider))
                    {
                        String[] optionalAssignmentString = operation.substring(1).split(
                            optionalDivider);
                        if (optionalAssignmentString.length == 2)
                        {
                            optionalOperatorDetected = true;
                            if (optionalAssignmentString[0].contains(equivalenceDivider))
                            {
                                String[] optionalCheckParts = optionalAssignmentString[0].split(
                                    equivalenceDivider);

                                if (optionalCheckParts.length == 2)
                                {
                                    Optional<String> settingType = getSettingType(optionalCheckParts[0]);
                                    if (settingType.isPresent()) {
                                        try {
                                            String valueToTest = profileData.getSpecificSettingAsString(optionalCheckParts[0]);
                                            String valueWeAreLookingFor = optionalCheckParts[1];
                                            boolean stopOnEquality = optionalAssignmentString[1].equals(
                                                    "|");
                                            
                                            if (valueToTest.equals(valueWeAreLookingFor)) {
                                                if (stopOnEquality) {
                                                    return Optional.empty();
                                                } else {
                                                    float valueToSet = Float.valueOf(
                                                            optionalAssignmentString[1]);
                                                    resultingValue = valueToSet;
                                                    doneProcessing = true;
                                                }
                                            } else {
                                                variable = valueElements[0];
                                            }
                                        } catch (NumberFormatException ex) {
                                            STENO.error("Error processing numeric value for "
                                                    + optionalCheckParts[1]);
                                        }
                                    } else {
                                        STENO.error("Error in query, setting does not exist with id: " + optionalCheckParts[0]);
                                    }
                                }
                            } else {
                                try {
                                    float valueToCheckFor = Float.valueOf(
                                        optionalAssignmentString[0]);
                                    float optionalAssignmentValue = Float.valueOf(
                                        optionalAssignmentString[1]);

                                    if (value == valueToCheckFor) {
                                        resultingValue = optionalAssignmentValue;
                                        doneProcessing = true;
                                    }
                                } catch (NumberFormatException ex) {
                                    // Failed to process...
                                    STENO.warning("Couldn't process optional slicer mapping: "
                                        + operation);
                                }
                            }
                        } else {
                            STENO.warning("Erroneous optional slicer mapping: " + operation);
                        }
                    }

                    if (!doneProcessing && !optionalOperatorDetected) {

                        float variableValue = 0;
                        Optional<String> settingType = getSettingType(variable);
                        
                        if(settingType.isPresent()) {
                            if (settingType.get().equals(INT)) {
                                variableValue = profileData.getSpecificIntSetting(variable);
                            } else if (settingType.get().equals(FLOAT) || settingType.get().equals(EXTRUSION)) {
                                variableValue = profileData.getSpecificFloatSetting(variable);
                            }
                        } else {
                            variableValue = Float.valueOf(variable);
                        }

                        switch (operator) {
                            case "*":
                                resultingValue = resultingValue * variableValue;
                                break;
                            case "[":
                                resultingValue = variableValue / resultingValue;
                                break;
                            case "/":
                                resultingValue = resultingValue / variableValue;
                                break;
                            case "+":
                                resultingValue = resultingValue + variableValue;
                                break;
                            case "-":
                                resultingValue = resultingValue - variableValue;
                                break;
                        }
                    }
                }
            }
        }

        return Optional.of(resultingValue);
    }

    private String extractSettingNameOrValue(String value) {
        String nameOrValue = value;

        if (value.contains(":")) {
            String[] elements = value.split(":");
            nameOrValue = elements[0];
        }

        return nameOrValue;
    }

    private Optional<String> getSettingType(String settingId) {
        PrintProfileSetting setting = printProfileSettingsMap.get(settingId);
        if(setting == null) {
            return Optional.empty();
        }
        return Optional.of(setting.getValueType());
    }
    
    private boolean isSettingPerExtruder(String settingId) {
        PrintProfileSetting setting = printProfileSettingsMap.get(settingId);
        return setting.isPerExtruder();
    }
    
    /**
     * Take a string in the form of numbers separated by commas, remove any trailing
     * commas and wrap in square brackets.
     * 
     * @param unformattedString the string to be formated to an 'array'
     * @return formatted String
     */
    private String formatStringIntoList(String unformattedString) {
        if(unformattedString == null || unformattedString.isEmpty()) {
            return "[]";
        }
        
        String listString = unformattedString.trim();

        return "[" + listString + "]";
    }
    
    /**
     * Make sure all settings are taken into account before mapping to the slicer.
     * This means settings which only exist in the print_profile_settings.json
     * are still taken into account.
     * 
     * @param profileData the {@link RoboxProfile} to add missing settings to.
     * @return 
     */
    private RoboxProfile extractNonOverridenSettings(RoboxProfile profileData) {
        Map<String, String> profileSettings = profileData.getSettings();
        
        printProfileSettingsMap.keySet().forEach(settingId -> {
            if(!profileSettings.containsKey(settingId)) {
                profileSettings.put(settingId, printProfileSettingsMap.get(settingId).getValue());
            }
        });
        
        profileData.setSettings(profileSettings);
        return profileData;
    }
        
    public SlicerType getSlicerType() {
        return slicerType;
    }
    
    protected abstract void outputLine(FileWriter writer, String variableName, boolean value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, int value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, float value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, String value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, SlicerType value) throws IOException;

    protected abstract void outputLine(FileWriter writer, String variableName, Enum value) throws IOException;

    protected abstract void outputPrintCentre(FileWriter writer, float centreX, float centreY) throws IOException;

    protected abstract void outputFilamentDiameter(FileWriter writer, float diameter) throws IOException;

    abstract void bringDataInBounds(RoboxProfile profileData);
}
